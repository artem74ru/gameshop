# Метрики производительности и сравнение режимов

## ТЕМА 2: Пагинация vs Бесконечный скролл

### Реализация

В проекте реализован переключатель режима загрузки:
- `mode=pagination` - Пагинация по страницам
- `mode=infinite` - Бесконечный скролл

Оба режима используют одну и ту же страницу каталога (`/catalog`), но с разным паттерном загрузки данных.

### Что измеряется

#### Lighthouse метрики
- **TTFB (Time to First Byte)** - время до первого байта ответа
- **LCP (Largest Contentful Paint)** - время загрузки самого большого контента
- **CLS (Cumulative Layout Shift)** - накопленное смещение макета

#### Сетевые метрики
- **Количество запросов** к server routes (`/api/games`)
- **Суммарный объем данных** (Network tab, байты)
- **Среднее время ответа** API (мс)

#### Метрики кеширования
- **Cache Hits** - количество попаданий в кеш
- **Cache Misses** - количество промахов кеша
- **Cache Hit Rate** - процент попаданий в кеш

#### Метрики внешних API
- **Количество запросов** к RAWG/CheapShark API
- **Количество ошибок** внешних API

### Сценарии пользователя

#### 1. Найти игру по названию и открыть карточку
**Пагинация:**
- Пользователь вводит название в поле поиска
- Применяется фильтр, загружается первая страница результатов
- URL обновляется с параметром `search=название`
- Пользователь кликает на игру, переходит на страницу игры
- При возврате назад (браузерная кнопка) - URL сохраняет параметры поиска, страница восстанавливается

**Infinite Scroll:**
- Пользователь вводит название в поле поиска
- Применяется фильтр, загружается первая страница результатов
- URL обновляется с параметром `search=название&mode=infinite`
- Пользователь кликает на игру, переходит на страницу игры
- При возврате назад - используется `sessionStorage` для восстановления позиции скролла и загруженных игр

#### 2. Отфильтровать по платформе и отсортировать
**Пагинация:**
- Пользователь выбирает платформу в фильтрах
- Применяется фильтр, загружается первая страница
- URL обновляется: `?platforms=1&sort=rating_desc&page=1`
- Пользователь меняет сортировку
- URL обновляется: `?platforms=1&sort=release_desc&page=1`
- Каждое изменение фильтров = новый запрос к API

**Infinite Scroll:**
- Пользователь выбирает платформу в фильтрах
- Применяется фильтр, сбрасывается накопленный список игр, загружается первая страница
- URL обновляется: `?platforms=1&sort=rating_desc&mode=infinite`
- Пользователь меняет сортировку
- URL обновляется: `?platforms=1&sort=release_desc&mode=infinite`
- При прокрутке вниз - автоматически загружаются следующие страницы

#### 3. Вернуться в каталог на то же место
**Пагинация:**
- URL содержит параметр `page=3`
- При загрузке страницы сразу загружается страница 3
- Пользователь видит ту же позицию в каталоге
- **Преимущество:** Воспроизводимость через URL, SEO-friendly

**Infinite Scroll:**
- Используется `sessionStorage` для сохранения:
  - Позиции скролла (`catalog_scroll_position`)
  - Количества загруженных игр (`catalog_game_count`)
- При возврате восстанавливается позиция скролла
- **Преимущество:** Плавный UX, не нужно ждать загрузки всех предыдущих страниц

### Выводы

**Пагинация лучше для:**
- Воспроизводимости (URL хранит состояние)
- SEO (каждая страница имеет уникальный URL)
- Предсказуемости (пользователь знает, на какой странице находится)
- Меньше запросов при навигации назад/вперед

**Infinite Scroll лучше для:**
- Сценария "просто листать" (непрерывный просмотр)
- Меньше кликов для просмотра большого количества контента
- Современный UX (как в социальных сетях)
- Но требует больше запросов при прокрутке

## ТЕМА 3: Кеширование и стабильность SSR

### Реализация

Используется `defineCachedEventHandler` из Nitro для кеширования API роутов:

#### Кешируемые эндпоинты

1. **`/api/games`** - TTL: 60 секунд
   - Частые запросы при скролле
   - Кеш на основе всех параметров запроса (page, search, sort, filters)

2. **`/api/games/[slug]`** - TTL: 120 секунд (2 минуты)
   - Детали игры меняются реже
   - Кеш на основе slug и priceStrategy

3. **`/api/genres`**, **`/api/platforms`**, **`/api/publishers`** и т.д. - TTL: 3600 секунд (1 час)
   - Справочные данные меняются редко
   - Долгий TTL для уменьшения нагрузки

4. **`/api/cheapshark/search`** (внутренний) - TTL: 24 часа
   - Поиск по названию повторяется
   - Кеш в `priceEnrichment.ts` через `priceCache`

### Метрики для сравнения "без кеша / с кешем"

#### Количество внешних запросов
- **Без кеша:** Каждый запрос к `/api/games` = запрос к RAWG API + запросы к CheapShark для каждой игры
- **С кешем:** Первый запрос = запрос к RAWG API + запросы к CheapShark, последующие = из кеша

#### Среднее время ответа API
- **Без кеша:** Время зависит от внешних API (RAWG ~200-500ms, CheapShark ~100-300ms на игру)
- **С кешем:** Время ответа из кеша ~1-10ms

#### Стабильность (меньше ошибок при лимитах)
- **Без кеша:** Каждый запрос может привести к rate limit ошибке
- **С кешем:** Запросы к внешним API только при cache miss, меньше вероятность rate limit

### Пример таблицы сравнения

| Метрика | Без кеша | С кешем | Улучшение |
|---------|----------|---------|-----------|
| Запросов к RAWG API (10 страниц) | 10 | 1-2 | 80-90% |
| Запросов к CheapShark API (10 страниц) | 200 | 20-40 | 80-90% |
| Среднее время ответа `/api/games` | 800ms | 15ms | 98% |
| Ошибки rate limit | Высокий риск | Низкий риск | Значительно |
| Cache Hit Rate | 0% | 70-85% | - |

### Cache-Control заголовки

Все кешируемые эндпоинты устанавливают правильные заголовки:
- `Cache-Control: public, max-age=60, s-maxage=60` (для `/api/games`)
- `X-Cache: HIT` или `X-Cache: MISS` для отладки

### Инвалидация кеша

Кеш автоматически инвалидируется по TTL:
- `/api/games` - каждые 60 секунд
- `/api/games/[slug]` - каждые 120 секунд
- Справочные данные - каждый час

Для принудительной инвалидации можно:
1. Изменить параметры запроса (создаст новый ключ кеша)
2. Подождать истечения TTL
3. Перезапустить сервер (in-memory кеш очистится)

## API для сбора метрик

### Сохранение метрик
**POST** `/api/performance/metrics`

```json
{
  "sessionId": "user-session-123",
  "mode": "pagination",
  "metrics": {
    "requestCount": 5,
    "totalDataSize": 245760,
    "averageResponseTime": 150,
    "cacheHits": 3,
    "cacheMisses": 2,
    "externalApiRequests": 2,
    "externalApiErrors": 0
  }
}
```

### Получение метрик
**GET** `/api/performance/metrics?sessionId=user-session-123&mode=compare`

Параметры:
- `sessionId` (обязательный) - ID сессии
- `mode` (опциональный) - `pagination`, `infinite`, `compare` или не указывать (все)

### Пример ответа для сравнения

```json
{
  "sessionId": "user-session-123",
  "comparison": {
    "pagination": {
      "average": {
        "requestCount": 3.2,
        "totalDataSize": 180000,
        "averageResponseTime": 120,
        "cacheHitRate": 75
      }
    },
    "infinite": {
      "average": {
        "requestCount": 8.5,
        "totalDataSize": 450000,
        "averageResponseTime": 95,
        "cacheHitRate": 60
      }
    },
    "differences": {
      "requestCount": 5.3,
      "totalDataSize": 270000,
      "averageResponseTime": -25,
      "cacheHitRate": -15
    }
  }
}
```

## Инструкции по сбору метрик

### 1. Lighthouse метрики

1. Откройте DevTools (F12)
2. Перейдите на вкладку "Lighthouse"
3. Выберите категории: Performance
4. Выберите устройство: Desktop или Mobile
5. Нажмите "Analyze page load"
6. Запишите метрики: TTFB, LCP, CLS

Повторите для обоих режимов (pagination и infinite).

### 2. Сетевые метрики

1. Откройте DevTools (F12)
2. Перейдите на вкладку "Network"
3. Очистите сеть (кнопка очистки)
4. Выполните сценарий пользователя
5. Запишите:
   - Количество запросов к `/api/games`
   - Общий размер данных (внизу вкладки Network)
   - Время ответа для каждого запроса

### 3. Метрики кеширования

1. Откройте DevTools (F12)
2. Перейдите на вкладку "Network"
3. Выполните сценарий пользователя
4. Проверьте заголовок `X-Cache` в ответах:
   - `X-Cache: HIT` - попадание в кеш
   - `X-Cache: MISS` - промах кеша
5. Подсчитайте количество HIT и MISS

### 4. Автоматический сбор через API

Используйте клиентский код для автоматического сбора метрик:

```javascript
// Генерация sessionId
const sessionId = `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`

// Сбор метрик после загрузки страницы
const metrics = {
  requestCount: performance.getEntriesByType('resource')
    .filter(r => r.name.includes('/api/games')).length,
  totalDataSize: performance.getEntriesByType('resource')
    .filter(r => r.name.includes('/api/games'))
    .reduce((sum, r) => sum + (r.transferSize || 0), 0),
  averageResponseTime: // вычислить среднее время ответа
  // ... другие метрики
}

// Отправка на сервер
await fetch('/api/performance/metrics', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ sessionId, mode: 'pagination', metrics })
})
```

## Рекомендации для курсовой

1. **Создайте тестовый сценарий:**
   - 10 пользователей выполняют одинаковые действия
   - 5 в режиме pagination, 5 в режиме infinite
   - Записывайте все метрики

2. **Сравните результаты:**
   - Таблица с метриками для каждого режима
   - Графики (если возможно)
   - Выводы о преимуществах каждого подхода

3. **Для кеширования:**
   - Тест "без кеша" (отключить кеш временно)
   - Тест "с кешем" (включить кеш)
   - Сравнить количество запросов, время ответа, стабильность

4. **Упомяните ограничения:**
   - Браузерный кеш может влиять на результаты
   - Необходимость корректных cache-control заголовков
   - Инвалидация кеша при изменении данных
