# Защита от блокировок CheapShark API

## Проблема

CheapShark API имеет rate limiting и может заблокировать IP адрес при превышении лимита запросов. API возвращает HTTP статус `429 Too Many Requests` при превышении лимита.

## Реализованные меры защиты

### 1. Rate Limiter (Ограничитель частоты запросов)

**Класс `CheapSharkRateLimiter`:**
- **Максимум 10 запросов в минуту** - ограничивает количество запросов
- **Минимум 6 секунд между запросами** - гарантирует задержку между запросами
- **Автоматическое ожидание** - если достигнут лимит, автоматически ждет до освобождения слота
- **Глобальный экземпляр** - один rate limiter для всех запросов к CheapShark API

**Реализация:**
```typescript
class CheapSharkRateLimiter {
  private requestTimes: number[] = []
  private readonly maxRequestsPerMinute = 10
  private readonly minDelayBetweenRequests = 6000 // 6 секунд
  // ...
}
```

### 2. Обработка 429 ошибок с Retry-After

**Механизм:**
- При получении `429 Too Many Requests` извлекается заголовок `Retry-After`
- Если `Retry-After` указан, система ждет указанное время перед повтором
- Если `Retry-After` не указан, используется экспоненциальная задержка (2^retryCount секунд)
- Максимум 2 попытки повтора для каждого запроса
- После получения 429, rate limiter блокирует все последующие запросы на время из `Retry-After`

**Реализация:**
```typescript
if (error?.statusCode === 429) {
  const retryAfterSeconds = parseInt(String(retryAfter), 10)
  rateLimiter.setBlock(retryAfterSeconds)
  // Ждем указанное время перед повтором
  await new Promise(resolve => setTimeout(resolve, retryAfterSeconds * 1000))
}
```

### 3. Кеширование результатов

**Серверное кеширование:**
- Endpoint `/api/games/[slug]/prices` кешируется на **2 часа** (7200 секунд)
- Используется `defineCachedEventHandler` из Nuxt 3/Nitro
- Кеш автоматически инвалидируется через 2 часа

**Кеширование списка магазинов:**
- Список магазинов кешируется в памяти на **1 час**
- Список магазинов меняется редко, поэтому кеш безопасен
- При 429 ошибке используется устаревший кеш, если доступен

**Реализация:**
```typescript
// Кеш для списка магазинов
const cachedStores = (globalThis as any)[storesCacheKey]
if (cachedStores && Date.now() - cachedStores.timestamp < storesCacheTTL) {
  stores = cachedStores.data // Используем кеш
}
```

### 4. Таймауты запросов

**Таймаут 10 секунд:**
- Каждый запрос к CheapShark API имеет таймаут 10 секунд
- Предотвращает зависание при медленном ответе API
- Автоматически прерывает долгие запросы

**Реализация:**
```typescript
const response = await $fetch<T>(url.toString(), {
  timeout: 10000, // 10 секунд
  // ...
})
```

### 5. Graceful Degradation (Плавная деградация)

**При недоступности API:**
- Если получен 429 и нет кеша, возвращается пустой массив `{ prices: [] }`
- Система продолжает работать, просто не показывает цены
- Пользователь видит сообщение об отсутствии цены (обрабатывается на клиенте)

**Реализация:**
```typescript
if (error?.statusCode === 429 || error?.status === 429) {
  return { prices: [] } // Возвращаем пустой результат вместо ошибки
}
```

## Параметры защиты

| Параметр | Значение | Описание |
|----------|----------|----------|
| `maxRequestsPerMinute` | 10 | Максимум запросов в минуту |
| `minDelayBetweenRequests` | 6000 мс | Минимальная задержка между запросами (6 секунд) |
| `maxRetries` | 2 | Максимум попыток повтора при 429 |
| `timeout` | 10000 мс | Таймаут запроса (10 секунд) |
| `pricesCacheTTL` | 7200 с | Время кеширования цен (2 часа) |
| `storesCacheTTL` | 3600000 мс | Время кеширования списка магазинов (1 час) |

## Логирование

Система логирует все важные события:
- `[CheapShark] Достигнут лимит запросов, ждем X секунд` - при достижении лимита
- `[CheapShark] API заблокирован на X секунд` - при получении 429 с Retry-After
- `[CheapShark] Получен 429, ждем X секунд перед повтором` - при повторе запроса
- `[Prices] Используем кешированный список магазинов` - при использовании кеша

## Рекомендации по использованию

1. **Не делать запросы автоматически** - запросы должны быть по действию пользователя (открытие страницы игры)
2. **Использовать кеш** - система автоматически кеширует результаты на 2 часа
3. **Мониторить логи** - следить за частотой 429 ошибок
4. **При частых 429** - увеличить `minDelayBetweenRequests` или уменьшить `maxRequestsPerMinute`

## Файлы

- `server/utils/cheapsharkClient.ts` - реализация rate limiter и обработка ошибок
- `server/api/games/[slug]/prices.get.ts` - endpoint для получения цен с кешированием

## Дополнительные меры (на будущее)

Если блокировки продолжаются, можно:
1. Увеличить `minDelayBetweenRequests` до 10-15 секунд
2. Уменьшить `maxRequestsPerMinute` до 5-7
3. Использовать Redis для распределенного rate limiting (если несколько серверов)
4. Реализовать очередь запросов с приоритетами
5. Использовать прокси-серверы для ротации IP (не рекомендуется для публичного API)
